# Jvm-HosSpot虚拟机对象探秘

前面我们了解了一下jvm虚拟机运行时数据分区，以及各个分区内存放什么，这一节我们详细了解一下虚拟机内存中数据的细节，他是如何从创建到布局到访问一系列过程，我们以最常用的内存区域java堆为例，深入了解一下虚拟机在java堆中对象分配，布局和访问的全过程。

## 对象创建

我们在java中创建一个普通的java对象都是用new去创建，而在jvm中,又经历了什么样的历程，

+ 1.首先java虚拟机遇到一条字节码指令new时，首先会去检查指令参数能否在常量池中定位到类符号引用，并且检查这个符号引用代表的类是否已经被加载，解析，初始化过咩，如果没有，先要经过类加载。

+ 2.类加载过后，jvm就会给新生对象分配内存，对象所需内存大小在类加载过程就确定了。那么这个分配内存过程就是在java堆中将一块内存空间划分出来。

+ 3.分配内存的算法

假如java堆内存是绝对规整的，被使用的内存在一边，没有使用的空闲内存在另外一边，中间放着一个指针，作为分界指示器，那么分配内存就是把这个指针朝着空闲那边移动一段和对象所需内存大小相当的距离，这种分配方式就叫<u>''指针碰撞''</u>

如果java堆内存不是规整的一块，那么就没办法碰撞了，这个时候虚拟机就会维护一个列表。记录哪一块内存是可用的，分配的时候就找一块足够大的空间去划分给对象实例，并且更新列表，这种分配方式就叫<u>"空闲列表"</u>

+ 4.采用什么分配方式基于采用垃圾收集器的种类

选择哪种分配方式得看堆内存是否规整，而java堆内存是否规整又得看采用的垃圾收集器是否有空间压缩整理的能力，所以当使用Serial,ParNew等带空间压缩整理能力的收集器时，系统采用的分配算法是指针碰撞，简单又高效当采用CMS这种基于标记清除算法的收集器的时候，理论上只能采用较为复杂的空闲列表来分配内存了。

+ 5.分配问题

因为对象创建在虚拟机中是非常频繁的行为，仅仅只靠着修改指针所指向的位置，并发情况下并不是线程安全的，因为可能会出现正在给A分配内存，执行还没来得及修改，对象B同时使用原来的指针来分配内存了。为了解决这个问题有两种方案

​    A.对分配内存空间动作进行同步处理----虚拟机采用的CAS配上失败重试的方式保证更新操作原子性。

​    B.把内存分配动作按照线程分在不同空间中进行，每个线程在java堆中预先分配一小块内存，成为本地线程分配缓冲(TLAB)，哪个线程需要分配内存，就在那个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区的时候才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定

分配完内存后，虚拟机还需要对对象实例进行必要的设置，例如对象是那个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等等信息，这些信息将保存在对象头中。

完成后，在虚拟机角度，一个新的对象就这么诞生了。但是从java程序来看，对象创建才刚刚开始。

---

## 对象的内存布局

对象在堆内存中的存储布局可以划分为三部分，对象头，实例数据，对齐填充。

+ 1.对象头

  对象头中包括两类信息

  A 用于存储对象自身运行时数据(如哈希码，GC分代年龄，锁状态标志，线程持有锁，偏向线程ID，偏向时间戳等等)

  B 类型指针，即对象指向他类型元数据的指针。jvm是通过这个指针来确定该对象是哪个类的实例。但是并不是所有虚拟机实现都必须在对象数据上保留类型指针。也就是说，查找对象的元数据信息并不一定要经过对象本身。

  此外如果说对象是数组的话。对象头中还必须有一块用于记录数据长度的数据。因为虚拟机是可以用对象元数据信息确定对象大小，但是数据长度不确定的话，就无法通过元数据中信息来知晓数组大小，所以对于数组来说，这一块记录数据长度的数据块是必须的。

+ 2.实例数据

  实例数据是对象真正存储的有效信息，即我们在代码中定义的各种类型的字段内容，不管是从父类继承下来的，还是子类中定义的字段都记录下来。

  这部分存储顺序是受虚拟机分配策略参数(-XX:FieldAllocationStyle参数)和java源码中定义顺序影响的，HotSpot虚拟机默认分配顺序是longs/doubles,ints,shorts/chars,bytes/booleans,oops(Ordinary Object Pointers,OOPs)，相同宽度的字段总是被分配到一起的，在满足这个前提条件下，如果分配策略参数-XX:FieldAllocationStyle 参数值为true，那么子类中比较窄的变量也是允许插入父类变量的空隙中的，节省了一部分空间。

+ 对齐填充

  对齐填充这一块并不是一定存在的。仅仅起到占位符作用。因为hotSpot 虚拟机的自动内存管理系统要求对象的起始位置必须是8字节的整数倍。也就是说任何对象的大小必须是8字节的整数倍。对象头部分已经被精心设计成了8字节的倍数。如果对象的实例数据部分没有对齐，那就靠对齐填充来补上。

  ----

  ## 对象访问定位

  对象创建，内存布局，到我们使用对象了，使用之前得定位到他，如何定位？

  java程序是会通过栈上的reference数据来操作堆上的具体对象了，这部分可以看看上一篇写的jvm 数据分区，虚拟机栈-栈帧中包括了局部变量表，局部变量表中里面有8种基本数据类型，对象的引用(reference类型)和returnAddress类型，那么就是这个对象引用的reference类型，对上号了。

  reference类型只是一个对象的引用，要具体访问方式的话也是由虚拟机决定，主流的两种是

  A 句柄访问

  使用句柄访问的话，java堆中将可能划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象的实例数据与类型数据各自具体的地址信息

  ![img](https://s1.ax1x.com/2020/11/05/BRBrMn.png)

  B 直接指针访问

  使用指针直接访问的话，java堆中对象的内存布局就要考虑如何存放访问类型数据相关信息了，reference中存放直接就是对象的地址，如果只是访问对象，就不需要多一次间接访问的开销

  ![img](https://s1.ax1x.com/2020/11/05/BRr74O.png)

两种访问方式各有优势

句柄访问最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾回收移动对象比较常见)的时候只会改变句柄中实例数据指针，reference本身不需要修改。

直接指针访问最大好处就是速度更快。节省了一次指针定位的时间开销。由于对象访问比较频繁，因此这类开销积少成多，也是一项极为可观的执行成本。

HotSpot虚拟机来说，主要使用的是直接指针访问。但是如果使用了Shenandoah收集器也会有一次额外转发。从整个软件开发范围而言，各种语言、框架中使用句柄访问情况也十分常见